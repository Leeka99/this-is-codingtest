# 왕실의 나이트

### 난이도 : 하
### 제한 풀이시간 : 20분
### 나의 풀이시간 : 시간초과

---
#### key point
- 나이트 이동 규칙에 따라서 총 8가지 경우의 수가 생긴다.
    - 나이트는 아래 2가지 경우로 이동할 수 있다.
        1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
        2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기
- 하지만 8가지의 방향에 대해 모두 코드를 작성할 것인가? 에 대한 고민으로 시간초과가 되었다.
    - 물론 8가지 방향을 모두 코드로 구현하는 것 말고는 다른 대안이 떠오르지 않았다.
    - 즉, 초기 접근 실패로 생각이 꼬여버렸다. 문제풀이 경험을 쌓아서 감을 익히는 것이 답이라 생각한다.
    
    ```
    // 내가 생각한 방법
    // 배열로 정의하고 싶어서 수직 또는 수평으로 2칸을 이동한 후 한칸을 어떻게 처리하지? 란 생각뿐이었다.
    // 하지만 이걸 어떻게 이용해야 할지 그리고 나머지 한칸을 처리하는 방법이 떠오르지 않았다.
    static int[] dx = {-2, 2, 0, 0};
    static int[] dy = {0, 0, 2, -2};
    ```

- 책에서의 풀이방법
    ```
    // 배열로 나이트가 이동할 수 있는 8가지 방향을 모두 정의한다.

    int[] dx = {-2, -1, 1, 2, 2, 1, -1, -2};
    int[] dy = {-1, -2, -2, -1, 1, 2, 2, 1};
    ```

- 추가적으로 이 문제에서는 유니코드 값 차이를 활용하는 것이 중요하다.
    ```
    // x 는 1 ~ 8까지의 정수가 입력됨 , y는 a ~ h 까지의 문자가 입력됨
    // 따라서 각각의 유니코드 값을 빼주면 초기 좌표 값을 얻을 수 있다. (x -> 0 ~ 7 , y -> 0 -> 7)

    String input = sc.nextLine();
    x = input.charAt(1) - '1';
    y = input.charAt(0) - 'a';
    ```